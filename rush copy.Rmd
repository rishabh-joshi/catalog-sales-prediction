---
title: "Predictive Analytics Project"
author: "Rush"
output: 
    html_document: 
        keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = "")
knitr::opts_chunk$set(fig.align = 'center')
```

## Data Preprocessing

Loading required libraries
```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(reshape2)
library(car)
library(bestglm)
library(caret)
library(glmnet)
library(SDMTools)
library(pROC)
```

Reading the data
```{r}
sales <- read.csv("catalog sales data.csv", stringsAsFactors = FALSE)
```

Adding a variable `responded` which indicates whether the customer responded or not. `responded` = 1 if and only if `targdol>0` else it is 0.
```{r}
sales <- sales %>%
    mutate(responded = as.integer(targdol>0)) %>%
    mutate(responded = factor(responded))
```

Converting the date variables into correct format and plotting histograms.
```{r}
sales$datead6 <- as.Date(sales$datead6, format = '%m/%d/%Y')
sales$datelp6 <- as.Date(sales$datelp6, format = '%m/%d/%Y')
```

Adding the variable `lpurseason` which is 'fall' if the last date
```{r}
sales <- sales %>%
    mutate(lpurseason = ifelse(month(sales$datelp6)>6, 'fall', 'spring')) %>%
    mutate(lpurseason = factor(lpurseason)) 
```

# Inconsistency in order history
## adding fall/spring categorical
```{r}
sales$lpurmonth <- month(sales$datelp6)
sales$season <- 'spring'
sales[sales$lpurmonth>6,]$season <- 'fall'
```


## updating order history
```{r}
difford <- sales$falord + sales$sprord - sales$ordhist
sales[difford >0,]$ordhist <- sales[difford > 0,]$falord + sales[difford > 0,]$sprord

for (i in 1:nrow(sales)) {
  if (difford[i] <0 && sales$season[i] =='spring') {
    sales$sprord[i] <- sales$ordhist[i]-sales$falord[i]
  }
  else if  (difford[i] <0 && sales$season[i] =='fall') {
    sales$falord[i] <- sales$ordhist[i]-sales$sprord[i]
  }
}

# check whether all fields are updated now
all(sales$falor+sales$sprord==sales$ordhist)  # true

```

# Manage inconsistency in datelp6 and lpuryear -- editted by Will
1. if lpuryear is NA ==> update it with the year parsed from 'datelp6'. The new variable is called 'datelp6_year'

2. if lpuryear is not NA ==>
  a. first convert them back to normal 4-digit years for our convenience
  b. compare it with 'datelp6_year', and update one of them with the larger one
  
```{r}
nna_lpuryear <- sales[!is.na(sales$lpuryear),]
table(nna_lpuryear$datelp6_year)
# the above table shows that all non-NA lpuryears are in between 2003-2012

sales$datelp6_year <- year(sales$datelp6)
# first change back to 4-digit years for those non-NA years
sales[!is.na(sales$lpuryear),]$lpuryear <- ifelse(sales[!is.na(sales$lpuryear),]$lpuryear<3,as.integer(paste0('201',as.character(sales[!is.na(sales$lpuryear),]$lpuryear))),as.integer(paste0('200',as.character(sales[!is.na(sales$lpuryear),]$lpuryear))))
# then fill in the NA years
sales[is.na(sales$lpuryear),]$lpuryear <- sales[is.na(sales$lpuryear),]$datelp6_year
# Update purchase year with greatest value
sales[sales$lpuryear < sales$datelp6,]$lpuryear <- sales[sales$lpuryear < sales$datelp6,]$datelp6_year
# Remove unneccessary datelp6_year column
sales <- sales[1:20]
```

# Select Date within [1985, 2012] for year added and [2003, 2012] for last purchase
```{r}
sales <- sales[(year(sales$datead6)>=1985) & (year(sales$datead6)<=2012),]
sales <- sales[(sales$lpuryear>=2003) & (sales$lpuryear<=2012),]
```

# rewrote the date variables?
```{r}
sales <- sales %>%
    mutate(datead6_int = as.integer(datead6)) %>%
    mutate(datelp6_int = as.integer(datelp6))
```




<!-- **This was in the whole data. Verify this again for only the training data.** -->
<!-- Four observations have datead6 = 6/1/1931. The next nearest date is 1/1/1980. Therefore, these observations might be potential outliers. This is shown below.  -->

<!-- ```{r} -->
<!-- # the earliest date -->
<!-- sale[which(train$datead6<0),] -->
<!-- # there are only 4 dates before 1/1/1970 -->

<!-- # the earliest date after 1/1/1970 -->
<!-- sale[which(sales$datead6 == min(sales$datead6[sales$datead6>0])), ] -->
<!-- ``` -->

Recency vector added, bin size of 6 months
```{r}
sales$recency <- 2*(2017 - sales$lpuryear)
sales[sales$lpurseason == "spring",]$recency <- 2*(2017 - sales[sales$lpurseason == "spring",]$lpuryear) + 1
```

Dividing the data into training and test set.
```{r}
train <- filter(sales, train == 1)
test <- filter(sales, train == 0)
```


Logistic regression
```{r}
log_fit_1 <- glm(responded ~ recency + datead6_int + datelp6_int + ordtyr + ordlyr + ord2ago + ord3ago + falord + sprord, family = binomial, data = train)
summary(log_fit_1)
```
```{r}
log1_pred <- predict(log_fit_1,train,type = 'response')  # find CCR 
tab1 <- table(train$responded,log_fit_1$fitted.values>0.53)
tab1
# CCR1 roughly 0.905, no better
caret::confusionMatrix(train$responded,as.integer(log_fit_1$fitted.values>0.53))
```

```{r}
plot.roc(train$responded, log1_pred, print.auc = TRUE)
```

```{r}
vif(log_fit_1)
```

```{r}
log_fit_2 <- glm(responded ~ recency + datead6_int + ordtyr + ordlyr + ord2ago + ord3ago + falord + sprord + ordtyr*ordlyr + ordlyr*ord2ago + ord2ago*ord3ago, family = binomial, data = train)
summary(log_fit_2)
```

```{r}
log2_pred <- predict(log_fit_2,train,type = 'response')  # find CCR
optim.thresh(train$responded, log2_pred)
```

```{r}
tab2 <- table(train$responded,log_fit_2$fitted.values>0.55)
tab2
# CCR1 roughly 0.905, no better
caret::confusionMatrix(train$responded,as.integer(log_fit_2$fitted.values>0.55))
```

```{r}
plot.roc(train$responded, log2_pred, print.auc = TRUE)
```

```{r}
vif(log_fit_2)
```

```{r}
log_fit_3 <- glm(responded ~ recency + datead6_int + slstyr + slslyr + sls2ago + sls3ago + falord + sprord + slstyr*slslyr + slslyr*sls2ago + sls2ago*sls3ago, family = binomial, data = train)
summary(log_fit_3)
```

```{r}
log3_pred <- predict(log_fit_3,train,type = 'response')
optim.thresh(train$responded, log3_pred)
```

```{r}
caret::confusionMatrix(train$responded,as.integer(log_fit_3$fitted.values>0.55))
```


```{r}
plot.roc(train$responded,log3_pred,print.auc=T)
vif(log_fit_3)
```

