---
title: "Data Cleaning"
author: "Jill Fan, Lauren Gardiner, Rush Joshi, Will Song"
date: "11/21/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading required libraries

```{r}
library(dplyr)
library(lubridate)
```



# Data cleaning

```{r}
sales <- read.csv("catalog sales data.csv", stringsAsFactors = FALSE)
```

## Adding an ID column to identify each customer uniquely

```{r}
sales <- mutate(sales, id = as.integer(row.names(sales)))
```

## Converting the date variables into correct format

```{r}
sales <- mutate(sales, datead6 = mdy(datead6), datelp6 = mdy(datelp6))
```

## Adding some features

A variable `responded` which indicates whether the customer responded or not. `responded` = 1 if and only if `targdol` > 0 else it is 0.

```{r}
sales <- sales %>%
    mutate(responded = as.integer(targdol>0)) %>%
    mutate(responded = factor(responded))
```

A variable `lpurseason` which is 'fall' if the last day of purchase is after June and 'spring' otherwise.

```{r}
sales <- sales %>%
    mutate(lpurseason = ifelse(month(sales$datelp6)>6, 'fall', 'spring')) %>%
    mutate(lpurseason = factor(lpurseason)) 
```

## Managing inconsistencies 

### Between `datelp6` and `lpuryear`

Updating NA values of `lpuryear` with the year parsed from `datelp6`. For the non NA values, first convert `datelp6` back to normal 4-digit years for our convenience and compare it with `datelp6_year`, and update one of them with the larger one.

```{r}
sales$datelp6_year <- year(sales$datelp6)
sales[!is.na(sales$lpuryear),]$lpuryear <- ifelse(sales[!is.na(sales$lpuryear),]$lpuryear<3,as.integer(paste0('201',as.character(sales[!is.na(sales$lpuryear),]$lpuryear))),as.integer(paste0('200',as.character(sales[!is.na(sales$lpuryear),]$lpuryear))))
sales[is.na(sales$lpuryear),]$lpuryear <- sales[is.na(sales$lpuryear),]$datelp6_year
sales[sales$lpuryear < sales$datelp6,]$lpuryear <- sales[sales$lpuryear < sales$datelp6,]$datelp6_year
sales <- select(sales, -datelp6_year)
```

### Between `falord`, `sprord` and `ordhist`
If the sum of `falord` and `sprord` are greater than `ordhist`, update `ordhist`. Else, update either `falord` or `sprord` with respect to `lpurseason`
```{r}
sales <- sales %>%
    mutate(ordhist = ifelse(ordhist<falord+sprord, falord+sprord, ordhist)) %>%
    mutate(sprord = ifelse(ordhist>falord+sprord & lpurseason == 'spring', 
                           ordhist-falord, sprord)) %>%
    mutate(falord = ifelse(ordhist>falord+sprord & lpurseason == 'fall', 
                           ordhist-sprord, falord))
```


**We cannot remove the columns from sales that lie outside this range because we will be removing data from the test set as well. We should only perform this action on the training data.**

Selecting `datead6` within year of [1985, 2012] and `lpuryear` within [2003, 2012].
```{r}
# sales <- sales[(year(sales$datead6)>=1985) & (year(sales$datead6)<=2012),]
# sales <- sales[(sales$lpuryear>=2003) & (sales$lpuryear<=2012),]
```

## Adding Additional Variables

Adding recency with bin sizes of 6 months.
```{r}
sales$recency_bin <- 2*(2017 - sales$lpuryear)
sales[sales$lpurseason == "spring",]$recency_bin <- 2*(2017 - sales[sales$lpurseason == "spring",]$lpuryear) + 1
```

Adding customer lifetime and recency by calculating days from date
```{r}
sales <- sales %>% 
    mutate(recency = as.integer(today() - datelp6)) %>%
    mutate(lifetime = as.integer(today() - datead6))
```

Adding active percentage based on lifetime and recency
```{r}
sales <- mutate(sales, active = (lifetime - recency)/lifetime)
```

Calculating average spend per order. If both slshist and ordhist are 0, NAs will be produced. We will replace those NAs by 0.
```{r}
sales <- mutate(sales, avg_amount = slshist/ordhist) %>%
    mutate(avg_amount = ifelse(is.na(avg_amount), 0, avg_amount))
```

Creating a Boolean for large purchase amount
```{r}
sales <- mutate(sales, large_avg = ifelse(avg_amount>mean(avg_amount), 1, 0))
```

Adding variable for season year
```{r}
sales$lpurseason_year <- paste(sales$lpurseason, sales$lpuryear, sep=" ")
```

Did the customer purchase within the last three years?
```{r}
sales <- mutate(sales, pur3yr = as.integer(year(datelp6)>=2010))
```

Did the cutomer spend more this year as compared to last year?
```{r}
sales <- mutate(sales, slscmp = as.integer(slstyr>slslyr))
```

We think there might some correlation between the sum of the sales in the last few years with the total number of sales to date, i.e. `slstyr + slslyr + sls2ago + sls3ago` might be correlated with `slshist`.

```{r}
with(sales, cor(slstyr + slslyr + sls2ago + sls3ago, slshist))
with(sales, cor(ordtyr + ordlyr + ord2ago + ord3ago, ordhist))
```

These correlations become significantly higher if we only consider the data where the customer responded

```{r}
with(filter(sales, responded == 1), cor(slstyr + slslyr + sls2ago + sls3ago, slshist))
with(filter(sales, responded == 1), cor(ordtyr + ordlyr + ord2ago + ord3ago, ordhist))
```

We can simply remove the `ordhist` and `slshist` variables. But we would be loosing some information if we do that. To remove multicollinearity and retain information, we add two more variables called `sls4bfr` and `ord4bfr` which are the total sales dollars and number of orders before 4 years. These can be obtained by subtracting the sum `slstyr + slslyr + sls2ago + sls3ago` from `slshist` and similarly for number of orders. Now we can remove the `ordhist` and `slshist` variables at the time of model building.

```{r}
sales <- sales %>%
    mutate(sls4bfr = slshist - slstyr - slslyr - sls2ago - sls3ago) %>%
    mutate(ord4bfr = ordhist - ordtyr - ordlyr - ord2ago - ord3ago)
```


# Dividing the data into training and test set.
```{r}
train <- filter(sales, train == 1)
test <- filter(sales, train == 0)
```

# Write out clean data

```{r}
write.csv(train, file = "clean_train.csv", row.names=FALSE)
write.csv(test, file = "clean_test.csv", row.names=FALSE)
```

